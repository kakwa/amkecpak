# vim: set noet ts=4:

# Various global variables
OUT_DIR := out
OUT_SRC := src-out
BUILD_DIR := builddir
CACHE := cache
DEB_MIRROR := http://ftp.debian.org/debian/
DIST_OS := $(shell echo $(DIST) | sed 's/-backports//')
DIST_TAG := $(shell ./buildenv/get_dist.sh $(DIST_OS))
PKGNAME := $(NAME)
MANIFEST_FILE := $(shell pwd)/MANIFEST
CACHE_DIR := $(shell pwd)/$(CACHE)/

# wget_sum.sh helper variable
# handles the manifest target (building of the MANIFEST file with checksums)
ifeq ($(MAKECMDGOALS), manifest)
WGS := ./buildenv/wget_sum.sh -c -m $(MANIFEST_FILE) -C "$(CACHE_DIR)"
else
WGS := ./buildenv/wget_sum.sh -m $(MANIFEST_FILE) -C "$(CACHE_DIR)"
endif

# git_sum.sh helper variable
# handles the manifest target (building of the MANIFEST file with checksums)
ifeq ($(MAKECMDGOALS), manifest)
GS := ./buildenv/git_sum.sh -c -m $(MANIFEST_FILE) -C "$(CACHE_DIR)"
else
GS := ./buildenv/git_sum.sh -m $(MANIFEST_FILE) -C "$(CACHE_DIR)"
endif

# Some variables for cowbuilder
COW_DIR := /var/cache/pbuilder/
ifeq ("$(DIST)", "")
DIST := unknown
else
COW_DIST := --distribution $(DIST_OS)
endif
ifeq ($(shell id -u), 1)
  COW_SUDO := 
else
  COW_SUDO := sudo
endif
COW_NAME := $(DIST).cow

ifneq ("$(DIST)", "sid")
OTHERMIRROR := deb $(DEB_MIRROR) $(DIST_OS)-backports main
endif

ifneq ("$(LOCAL_REPO_PATH)", "")
  ifneq ("$(LOCAL_REPO_PATH)", "")
    OTHERMIRROR := $(OTHERMIRROR)|
  endif
  OTHERMIRROR := $(OTHERMIRROR)deb [trusted=yes] file://$(LOCAL_REPO_PATH) /
  BINDMOUNT := --bindmounts "$(LOCAL_REPO_PATH)"
endif


OTHERMIRROR := --othermirror "$(OTHERMIRROR)"

.NOTPARALLEL: deb rpm clean deb_chroot manifest

.PHONY: all rpm_prepare rpm deb clean_build clean_cache clean rm_manifest_file manifest deb_chroot help

# Name of the root directory of the archive
SOURCE_DIR := $(BUILD_DIR)/$(PKGNAME)-$(VERSION)
# Name of the source archive
SOURCE_ARCHIVE := $(BUILD_DIR)/$(PKGNAME)_$(VERSION).orig.tar.gz
# Command used to build the source archive
SOURCE_TAR_CMD := cd `dirname $(SOURCE_DIR)` && tar -zcf $(PKGNAME)_$(VERSION).orig.tar.gz `basename $(SOURCE_DIR)` --owner=root --group=root && rm -r `basename $(SOURCE_DIR)`/* || rm -f $(PKGNAME)_$(VERSION).orig.tar.gz; touch $(PKGNAME)_$(VERSION).orig.tar.gz

# Some targets
DIRECTORIES := $(BUILD_DIR) $(OUT_DIR) $(OUT_SRC) $(CACHE) $(BUILD_DIR)/deb.$(DIST) $(SOURCE_DIR) $(BUILD_DIR)/rpm.$(DIST)

#### START common targets

all: deb rpm

# Create the build directories
$(DIRECTORIES):
	mkdir -p $(BUILD_DIR)
	mkdir -p  $(OUT_DIR)
	mkdir -p  $(OUT_SRC)
	mkdir -p  $(CACHE)
	mkdir -p $(BUILD_DIR)/deb.$(DIST)
	mkdir -p $(BUILD_DIR)/rpm.$(DIST)
	mkdir -p $(SOURCE_DIR)

# Cleaning targets
clean_build:
	if [ -d $(BUILD_DIR) ]; then chmod 700 -R $(BUILD_DIR);rm -rf $(BUILD_DIR);fi

clean_cache:
	if [ -d $(CACHE) ] && ! [ "$(KEEP_CACHE)" = "true" ]; then chmod 700 -R $(CACHE); rm -rf $(CACHE);fi

clean: clean_build clean_cache
	if [ -d $(OUT_DIR) ]; then chmod 700 -R $(OUT_DIR);rm -rf $(OUT_DIR);fi
	if [ -d $(OUT_SRC) ]; then chmod 700 -R $(OUT_SRC);rm -rf $(OUT_SRC);fi

# Build MANIFEST target
rm_manifest_file:
	if [ -f $(MANIFEST_FILE) ]; then  rm $(MANIFEST_FILE);fi
	touch MANIFEST

manifest: rm_manifest_file clean_cache $(SOURCE_ARCHIVE)

#### END common targets

#### START DEB targets

# Some variables
DEB_CONTENT := $(BUILD_DIR)/debian/changelog $(BUILD_DIR)/$(PKGNAME)_$(VERSION).orig.tar.gz
DEB_CONTENT_DIST := $(filter-out debian/control.dist.$(DIST) debian/rules.dist.$(DIST), $(wildcard debian/*.dist.$(DIST)))
DEB_CONTENT_BASE := $(filter-out $(wildcard debian/*.dist.*) debian/changelog debian/control debian/rules, $(wildcard debian/*))
DEB_CONTENT_IN := $(DEB_CONTENT_DIST) $(shell for f in $(DEB_CONTENT_BASE);do if ! [ -e $$f.dist.$(DIST) ];then echo $$f;fi;done)
DEB_CONTENT_OUT := $(subst .dist.$(DIST),,$(addprefix $(BUILD_DIR)/deb.$(DIST)/$(PKGNAME)-$(VERSION)/, $(DEB_CONTENT_IN)))
ifneq ("$(wildcard debian/rules.dist.$(DIST))","")
DEB_RULE_IN := debian/rules.dist.$(DIST)
else
DEB_RULE_IN := debian/rules
endif
ifneq ("$(wildcard debian/control.dist.$(DIST))","")
DEB_CONTROL_IN := debian/control.dist.$(DIST)
else
DEB_CONTROL_IN := debian/control
endif
DEB_ARCHIVE := $(BUILD_DIR)/deb.$(DIST)/$(PKGNAME)_$(VERSION).orig.tar.gz
DEB_PREPARE := $(DEB_ARCHIVE) $(DEB_CONTENT_OUT) $(BUILD_DIR)/deb.$(DIST)/$(PKGNAME)-$(VERSION)/debian/changelog $(BUILD_DIR)/deb.$(DIST)/$(PKGNAME)-$(VERSION)/debian/control $(BUILD_DIR)/deb.$(DIST)/$(PKGNAME)-$(VERSION)/debian/rules

# Copy all the files of debian/ packaging directory
$(DEB_CONTENT_OUT): $(DEB_CONTENT_IN)
	mkdir -p $(BUILD_DIR)/deb.$(DIST)/$(PKGNAME)-$(VERSION)/debian/
	f=$(subst $(BUILD_DIR)/deb.$(DIST)/$(PKGNAME)-$(VERSION)/,,$@);\
	if [ -e $$f.dist.$(DIST) ];\
	then\
	    cp -r $$f.dist.$(DIST) $@;\
	else\
	    cp -r $$f $@;\
	fi

# Substitute version and package name in control file
$(BUILD_DIR)/deb.$(DIST)/$(PKGNAME)-$(VERSION)/debian/control $(BUILD_DIR)/deb.$(DIST)/$(PKGNAME)-$(VERSION)/debian/rules: $(DEB_CONTROL_IN) $(DEB_RULE_IN)
	f=$(subst $(BUILD_DIR)/deb.$(DIST)/$(PKGNAME)-$(VERSION)/,,$@);\
	if [ -e $$f.dist.$(DIST) ];\
	then\
	    cp -r $$f.dist.$(DIST) $@;\
	else\
	    cp -r $$f $@;\
	fi
	sed -i 's|@NAME@|$(PKGNAME)|;s|@VERSION@|$(VERSION)|;s|@RELEASE@|$(RELEASE)|;s|@DESCRIPTION@|$(DESCRIPTION)|;s|@SUMMARY@|$(SUMMARY)|;s|@URL@|$(URL)|' $@

# Generate generic changelog
$(BUILD_DIR)/deb.$(DIST)/$(PKGNAME)-$(VERSION)/debian/changelog: ./debian/changelog
	mkdir -p $(BUILD_DIR)/deb.$(DIST)/$(PKGNAME)-$(VERSION)/debian
	printf "$(PKGNAME) ($(VERSION)-$(RELEASE)~up+deb$(DIST_TAG)) $(DIST); urgency=low\\n"  > $@
	printf "\\n  * New version\\n\\n" >> $@
	printf " -- kakwa <carpentier.pf@gmail.com>  %s\\n" "`LANG=C date '+%a, %d %b %Y %T %z'`" >> $@

# put the archive in the proper directory
$(DEB_ARCHIVE): $(SOURCE_ARCHIVE) | $(DIRECTORIES)
	cp $(SOURCE_ARCHIVE) $(DEB_ARCHIVE)

# Build the deb(s) and put it in out directory
$(BUILD_DIR)/pkg_built.deb.$(DIST): $(DEB_PREPARE) | $(DIRECTORIES)
	tar -xf $(DEB_ARCHIVE) -C $(BUILD_DIR)/deb.$(DIST)
	cd $(BUILD_DIR)/deb.$(DIST)/$(PKGNAME)-$(VERSION) && \
	dpkg-buildpackage -us -uc;\
	if [ $$? -ne 0 ];\
		then touch $(BUILD_DIR)/failure;exit 1;\
		else rm -f $(BUILD_DIR)/failure;exit 0;\
	fi
	find $(BUILD_DIR)/ -type f -name "*.deb" -exec mv {} $(OUT_DIR)/ \;
	find $(BUILD_DIR)/ -type f -name "*.orig.tar.gz" -exec cp {} $(OUT_SRC)/ \;
	find $(BUILD_DIR)/ -type f -name "*.dsc" -exec mv {} $(OUT_SRC)/ \;
	find $(BUILD_DIR)/ -type f -name "*debian.tar.xz" -exec mv {} $(OUT_SRC)/ \;
	touch $(BUILD_DIR)/pkg_built.deb.$(DIST)

# the target to be called for building .deb
deb: $(BUILD_DIR)/pkg_built.deb.$(DIST)

# Build the deb(s) in a chroot (cowbuilder) and put it in out directory
$(BUILD_DIR)/pkg_built_chroot.deb.$(DIST): $(DEB_PREPARE) | $(DIRECTORIES)
	cowbuilder --help >/dev/null
	cd $(BUILD_DIR)/deb.$(DIST)/$(PKGNAME)-$(VERSION) && \
	     dpkg-source -b ./
	if ! [ -e $(COW_DIR)/$(COW_NAME) ];\
	then\
	    export TMPDIR=/tmp/; $(COW_SUDO) cowbuilder create --debootstrap debootstrap $(COW_DIST) $(OTHERMIRROR) --basepath $(COW_DIR)/$(COW_NAME) --mirror $(DEB_MIRROR) $(BINDMOUNT);\
	else\
	    export TMPDIR=/tmp/; $(COW_SUDO) cowbuilder update --basepath $(COW_DIR)/$(COW_NAME) $(BINDMOUNT);\
	fi
	export TMPDIR=/tmp/; $(COW_SUDO) cowbuilder build $(BUILD_DIR)/deb.$(DIST)/*.dsc  --basepath $(COW_DIR)/$(COW_NAME) --buildresult $(OUT_DIR)/ $(OTHERMIRROR) --mirror $(DEB_MIRROR) $(BINDMOUNT); \
	if [ $$? -ne 0 ];\
		then touch $(BUILD_DIR)/failure;exit 1;\
		else rm -f $(BUILD_DIR)/failure;exit 0;\
	fi
	find $(OUT_DIR)/ -type f -name "*.orig.tar.gz" -exec mv {} $(OUT_SRC)/ \;
	find $(OUT_DIR)/ -type f -name "*.dsc" -exec mv {} $(OUT_SRC)/ \;
	find $(OUT_DIR)/ -type f -name "*.changes" -exec mv {} $(OUT_SRC)/ \;
	find $(OUT_DIR)/ -type f -name "*.buildinfo" -exec mv {} $(OUT_SRC)/ \;
	find $(OUT_DIR)/ -type f -name "*debian.tar.xz" -exec mv {} $(OUT_SRC)/ \;
	touch $(BUILD_DIR)/pkg_built_chroot.deb.$(DIST)

# The target to be called for building .deb in chroot
deb_chroot: $(BUILD_DIR)/pkg_built_chroot.deb.$(DIST)

#### END DEB targets

#### START RPM targets

# Some variables for rpm build
RPM_DIR := $(BUILD_DIR)/rpm.$(DIST)/BUILDROOT $(BUILD_DIR)/rpm.$(DIST)/RPMS  $(BUILD_DIR)/rpm.$(DIST)/SRPMS 
RPM_SPEC := $(BUILD_DIR)/rpm.$(DIST)/SPEC/$(PKGNAME).spec
RPM_ARCHIVE := $(BUILD_DIR)/rpm.$(DIST)/SOURCES/$(PKGNAME)-$(VERSION).tar.gz
RPM_CONTENT_DIST := $(filter-out rpm/component.spec.dist.$(DIST), $(wildcard rpm/*.dist.$(DIST)))
RPM_CONTENT_BASE := $(filter-out $(wildcard rpm/*.dist.*) rpm/component.spec, $(wildcard rpm/*))
RPM_CONTENT_IN := $(RPM_CONTENT_DIST) $(shell for f in $(RPM_CONTENT_BASE);do if ! [ -e $$f.dist.$(DIST) ];then echo $$f;fi;done)
RPM_CONTENT_OUT := $(subst .dist.$(DIST),,$(addprefix $(BUILD_DIR)/rpm.$(DIST)/SOURCES/, $(subst rpm/,,$(RPM_CONTENT_IN))))
ifneq ("$(wildcard rpm/component.spec.dist.$(DIST))","")
RPM_SPEC_IN := rpm/component.spec.dist.$(DIST)
else
RPM_SPEC_IN := rpm/component.spec
endif

fake:
	@echo "BASE"
	@echo $(RPM_CONTENT_BASE)
	@echo "IN"
	@echo $(RPM_CONTENT_IN)
	@echo "OUT"
	@echo $(RPM_CONTENT_OUT)

# Create the various rpmbuild directories
$(RPM_DIR): $(BUILD_DIR)/rpm.$(DIST) 
	mkdir $@

# Copy the upstream sources archive to SOURCES with correct name
$(RPM_ARCHIVE): $(SOURCE_ARCHIVE)
	mkdir -p $(BUILD_DIR)/rpm.$(DIST)/SOURCES
	rm -f $(RPM_ARCHIVE)
	cp -r $(SOURCE_ARCHIVE) $(RPM_ARCHIVE)

# Copy the additional content of the rpm/ directory in SOURCES (use for stuff like .service files)
$(RPM_CONTENT_OUT): $(RPM_CONTENT_IN) $(RPM_SPEC)
	mkdir -p $(BUILD_DIR)/rpm.$(DIST)/SOURCES
	f=rpm/$(subst $(BUILD_DIR)/rpm.$(DIST)/SOURCES/,,$@);\
	if [ -e $$f.dist.$(DIST) ];\
	then\
	    cp -r $$f.dist.$(DIST) $@;\
	else\
	    cp -r $$f $@;\
	fi


# Copy the spec file and do the various substitutions in it
$(RPM_SPEC): $(RPM_SPEC_IN)
	mkdir -p $(BUILD_DIR)/rpm.$(DIST)/SPEC
	cp $(RPM_SPEC_IN) $(RPM_SPEC)
	sed -i 's|@NAME@|$(PKGNAME)|;s|@VERSION@|$(VERSION)|;s|@RELEASE@|$(RELEASE)|;s|@DESCRIPTION@|$(DESCRIPTION)|;s|@SUMMARY|$(SUMMARY)|;s|@URL@|$(URL)|' \
		$(RPM_SPEC) || rm -f $(RPM_SPEC)

# Build the rpm(s) and put the result inside out directories
$(BUILD_DIR)/pkg_built.rpm.$(DIST): $(SOURCE_ARCHIVE) $(RPM_ARCHIVE) $(RPM_SPEC) $(RPM_CONTENT_OUT)
	rpmbuild -ba --define "_topdir $(CURDIR)/$(BUILD_DIR)/rpm.$(DIST)" \
                                --define "_sourcedir %{_topdir}/SOURCES" \
                                --define "_specdir %{_topdir}/SPEC" \
                                --define "_rpmdir %{_topdir}/RPMS" \
                                --define "_srcrpmdir %{_topdir}/SRPMS" \
                                --define "_tmppath %{_topdir}/BUILDROOT" \
                                --define "_builddir %{_topdir}/BUILD" \
                                --define "dist .$(DIST_TAG)" \
                                $(BUILD_DIR)/rpm.$(DIST)/SPEC/$(PKGNAME).spec
	find $(BUILD_DIR)/rpm.$(DIST) -type f -name "*.src.rpm" -exec mv {} $(OUT_SRC)/ \;
	find $(BUILD_DIR)/rpm.$(DIST) -type f -name "*.rpm" -exec mv {} $(OUT_DIR)/ \;
	touch $(BUILD_DIR)/pkg_built.rpm.$(DIST)

# The rpm target to be called
rpm: $(BUILD_DIR)/pkg_built.rpm.$(DIST)

#### END RPM targets

#### START help target ####

define MAKE_HELP
Available targets:

* help       : Display this help


* manifest   : Download the upstream sources
               and (re)build the MANIFEST file
               with the checksum of the upstream sources.

               Running "make clean" is advisable before running
	       "make manifest".


* clean      : Remove various work directories:
               - builddir/ (build directory),
               - cache/ (upstream sources cache directory),
               - out/ (output directory for packages),
               - src-out/ (output directory for source packages)

               It's possible to keep the cache directory
               with "KEEP_CACHE=true": "make clean KEEP_CACHE=true"


* deb        : Build the .deb packages


* rpm        : Build the .rpm packages


* deb_chroot : Build the .deb packages in a clean chroot (using cowbuilder)

               The targeted distribution version can be specified using
               the "DIST=<code name>", for example "make deb_chroot DIST=stretch"

               this target requires root permission for cowbuilder
               (sudo or run directly as root)


* rpm_chroot : not implemented yet

endef

export MAKE_HELP
help:
	@echo "$$MAKE_HELP"

#### END help target ####
